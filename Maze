import java.awt.Graphics;
import javax.swing.Timer;
import java.sql.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import java.awt.*;
public abstract class Maze extends JPanel{
	private Grid grid;
	private ArrayList<GridSpace> blockedSpaces;
	private String bestTime="00:00";
	private boolean completed=false;
	private Player player;
	private int pixelConstant=10;
	private Timer timer;
	private boolean failed=false;
	private DisplayGame game;
	private TrackTime timeTracker;
	public Maze(DisplayGame game){
		this.game=game;
		setPreferredSize(new Dimension(300,300));
		pixelConstant=(int)getPreferredSize().getWidth()/30;
		setGrid();
		setPlates();
		timer=new Timer(800,new TimerListener());
		timer.setInitialDelay(0);
		timeTracker=new TrackTime();
	}
	abstract ArrayList<Plate> getPlates();
	abstract ArrayList<SlidingPlate> getSlidingPlates();
	abstract void setPlates();
	abstract int gridWidth();
	abstract int gridHeight();
	abstract String getLevel();
	abstract GridSpace gameCompleteSpace();
	abstract void addPlayer(Player toAdd);
	abstract GridSpace playerStart();
	abstract ArrayList<Monster> getMonsters();
	abstract boolean platesRandom();
	public void setPixelConstant(int newConstant){
		pixelConstant=newConstant;
	}
	public void pauseTimer(){
		timeTracker.stopTiming();
		timer.stop();
	}
	
	public void startTimer(){
		timer.start(); 
		timeTracker.startTiming();
	}
	public void restartTimer(){
		timeTracker.startTiming();
	}
	public String getTime(){
		return timeTracker.getTime();
	}
	public int getPixelConstant(){
		return pixelConstant;
	}
	public Player getPlayer(){
		return player;
	}
	public void setPlayer(Player newPlayer){
		player=newPlayer;
		addPlayer(player);
	}
	public void completeLevel(){
		completed=true;
	}
	public boolean isCompleted(){
		//return true;
		return completed;
	}
	public boolean isFailed(){
		return failed;
	}
	
	public String getBestTime(){
		return bestTime;
	}
	public Grid getGrid(){
		return grid;
	}
	private void setGrid(){
		grid=new Grid(gridWidth(),gridHeight());

	}
	private void addPlateToGrid(Plate toAdd){
		getPlates().add(toAdd);

	}
	private int numPlates(){
		return getPlates().size();
	}
	public boolean gameComplete(){
		return player.getOccupiedSpot().equals(gameCompleteSpace());
	}
	public void movePlayer(String direction){
		
		GridSpace newSpace=player.getOccupiedSpot();
		GridSpace currentSpace=player.getOccupiedSpot();
		if (direction.equals("Left")){
			if (currentSpace.getX()>0)
				newSpace=grid.getGridSpace(currentSpace.getX()-1, currentSpace.getY());
		}else if (direction.equals("Right")){
			if (currentSpace.getX()<gridWidth()-1)
				newSpace=grid.getGridSpace(currentSpace.getX()+1, currentSpace.getY());
		}else if (direction.equals("Up")){
			if (currentSpace.getY()>0)
				newSpace=grid.getGridSpace(currentSpace.getX(), currentSpace.getY()-1);
		}else if (direction.equals("Down")){
			if (currentSpace.getY()<gridHeight()-1)
				newSpace=grid.getGridSpace(currentSpace.getX(), currentSpace.getY()+1);
		}else{
			newSpace=player.getOccupiedSpot();
		}
		if (!newSpace.getOccupied()){
			player.changeOccupiedSpot(newSpace);
			repaint();
		}
		if (newSpace.equals(gameCompleteSpace())){
			completed=true;
			timeTracker.stopTiming();
			String newBest=timeTracker.compareTimes(timeTracker.getTime(), bestTime);
			
			bestTime=newBest;
			timeTracker.refreshTimer();
		}
		for (Monster monster : getMonsters()){
			if (monster.getOccupiedSpot()==newSpace){
				failed=true;
				timeTracker.refreshTimer();
				game.failedMaze();
			}
		}
		
		

	}
	public void paintComponent(Graphics g){
		super.paintComponent(g);
		Graphics2D g2=(Graphics2D)g;
		g2.setColor(Color.black);
		for (int counter=0;counter<gridWidth();counter++){
			g2.drawLine(counter*pixelConstant, 0, counter*pixelConstant, gridHeight()*pixelConstant);
		}
		for (int counter=0;counter<gridHeight();counter++){
			g2.drawLine(0,counter*pixelConstant,gridWidth()*pixelConstant,counter*pixelConstant);
		}
		setSize(gridWidth()*pixelConstant,gridHeight()*pixelConstant);
		setBackground(Color.yellow);
		blockedSpaces=new ArrayList<GridSpace>();
		if (getPlates().size()>0){
			for (Plate current : getPlates()){
				for (int counter=0;counter<current.getSpacesCovered().length;counter++){
					blockedSpaces.add(current.getSpacesCovered()[counter]);
				}
			}
		}
		g2.setColor(Color.black);
		for (int counter=0;counter<blockedSpaces.size();counter++){
			GridSpace current=blockedSpaces.get(counter);
			g2.fillRect(current.getX()*pixelConstant, current.getY()*pixelConstant, pixelConstant, pixelConstant);
		}
		g2.setColor(Color.cyan);

		g2.fillOval(player.getOccupiedSpot().getX()*pixelConstant,player.getOccupiedSpot().getY()*pixelConstant,pixelConstant,pixelConstant);
		
		g2.setColor(Color.orange);
		
		for (Monster current : getMonsters()){
			GridSpace position=current.getOccupiedSpot();
			g2.fillRect(position.getX()*pixelConstant, position.getY()*pixelConstant, pixelConstant, pixelConstant);
		}
		g2.setColor(Color.green);
		g2.fillRect(gameCompleteSpace().getX()*pixelConstant, gameCompleteSpace().getY()*pixelConstant,pixelConstant,pixelConstant);
		
	}
	class TimerListener implements ActionListener{
		public void actionPerformed(ActionEvent e){
			for (Monster current : getMonsters()){
				current.move();
				if (current.getOccupiedSpot()==player.getOccupiedSpot()&&!failed){
					System.out.println(failed);
					failed=true;
					timeTracker.refreshTimer();
					game.failedMaze();
				}
			}
			for (SlidingPlate current : getSlidingPlates()){
				if (!platesRandom()||(int)(Math.random()*10)<5)
					current.move();
				for (int counter=0;counter<current.getSpacesCovered().length;counter++){
					if (current.getSpacesCovered()[counter]==player.getOccupiedSpot()){
						failed=true;
						timeTracker.refreshTimer();
						game.failedMaze();
					}
				}
			}
			repaint();
		}
	}
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
